---
title: "Introduction and Growth Rates"
author: "Paulo Fagandini, PhD"
institute: "Lisbon Accounting and Business School – Polytechnic University of Lisbon"
format:
  revealjs:
    theme: default
    slide-number: true
    incremental: true
    math: katex
    transition: slide
    footer: "Statistics I"
    from: markdown+emoji
    code-overflow: wrap
    code-block-font-size: 0.75em
    progress: true
jupyter: python3
---

# Course Introduction

## Core Information

**Instructor:** Paulo Fagandini

:email: pfagandini@iscal.ipl.pt

\

**Main source for course material:** Moodle@ISCAL

**Alternative source (EN):** [pfagandini.github.io/statistics1.html](https://pfagandini.github.io/statistics1.html)

\

**Official communication channel:** :email: Institutional Email

## Bibliography

### Topic 1:
:book: A Practical Introduction to Index Numbers. 1^st^ Ed 2015. Jeff Ralph, Rob O'Neill, Joe Winton.

### Topics 2 and 3:
:book: Statistics for Business and Economics Global Edition. 10^th^ Ed 2022. Paul Newbold, William Carlson, and Betty Thorne.

\

<small>This last book is a bit expensive, but it can be rented for less money [here](https://eu.pearson.com/statistics-for-business-and-economics-global-edition/9781292438306). The Publisher kindly offered a 25% discount with the code **MISLIBROS2025**. This code is valid for the whole site until December 31^st^ , 2025.</small>

## Continuous Assessment

| Assessment Element | Weight (%) | Duration | Syllabus | Date |
|-------------------| ------------| ---------| -------- | ---- |
| Midterm | 60% | 80 minutes| Topics 1 and 2 | Week Nov 11-15  |
| Partial Exam | 40% | 80 minutes | Topic 3| Regular Exam Date |

<small>Each test has a minimum grade of 7.00 (out of 20), not 6.9, not 6.95.</small>

## Comprehensive Exam

Students may opt, on the day of the Exam, to take an Exam worth 100% of the grade. This Exam will cover Topics 1, 2, and 3.

\

If you score less than 7.00 in the Midterm, or if you cannot attend the midterm for whatever reason, you **will** have to do the Comprehensive Exam.

# Growth Rates

## Example

```{python}
#| echo: false
#| fig-width: 16
#| fig-height: 8

import pandas_datareader.data as web
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime, timedelta
from IPython.display import Markdown

# Set up date range for last 10 years
end_date = datetime.now()
start_date = end_date - timedelta(days=365*6)

# Get Italian GDP data from FRED
italy_gdp = web.DataReader('CLVMNACSCAB1GQIT', 'fred', start_date, end_date)

# Convert to annual data
annual_gdp = italy_gdp.resample('Y').last()
annual_gdp.index = annual_gdp.index.year
```

:::columns
:::{.column width="50%"}

Italian Real GDP (base = 2010)

```{python}
#| echo: false
# Create DataFrame for table
gdp_table = pd.DataFrame({
    'Year': annual_gdp.index,
    'GDP (Millions €)': annual_gdp.iloc[:, 0].round(0).astype(int)
})

gdp_table['GDP (Millions €)'] = gdp_table['GDP (Millions €)'].apply(lambda x: f"{x:,.0f}")
markdown_table = gdp_table.to_markdown(index = False, stralign = "left", numalign = "right")
Markdown(markdown_table)
```

Source: FRED

:::

:::{.column width="50%"}
```{python}
#| echo: false
#| fig-width: 5
#| fig-height: 3

plt.figure(figsize = (5, 3))
plt.plot(annual_gdp.index, annual_gdp.iloc[:, 0], 
         marker = 'o', linewidth = 3, markersize = 8, color = '#4472C4')

plt.title('GDP', fontsize = 16, fontweight = 'bold')
plt.xlabel('Year', fontsize = 12)
plt.ylabel('GDP (Millions of Euros)', fontsize = 12)

plt.tight_layout()
plt.show()
```

:::
:::

```{python}
# putting the dataset in usable variables for practicality

def d(x):
  display(Markdown(x))

y = []
ys = []
v = []
vs = []

for i in range(5):
  y.append(annual_gdp.index[i])
  ys.append(f"{y[i]:.0f}")

  v.append(round(annual_gdp.iloc[i,0]))
  vs.append(f"{v[i]:,.0f}")

```

## Example

Let the GDP for Italy be represented by the variable $y_t$, so $y_{`{python} ys[0]`}$ is the GDP we got for `{python} ys[0]` (*i.e.* `{python} vs[0]`).

How much did $y$ grow between `{python} ys[0]` and `{python} ys[1]`? 

. . .

$$\Delta y_{`{python} ys[1]`} = y_{`{python} ys[1]`} - y_{`{python} ys[0]`} = `{python} vs[1]` - `{python} vs[0]`$$

. . .
```{python}
d(f'$$={v[1]-v[0]}$$')
```

. . .

Or we could say

```{python}
d(f"$$y_{{{y[1]}}}=y_{{{y[0]}}}+\\Delta y_{{{y[1]}}}$$")
d(f'$${v[1]}={v[0]}+({v[1]-v[0]})$$')
```

## Example

```{python}
d(f"$$y_{{{y[1]}}}=y_{{{y[0]}}}+\\Delta y_{{{y[1]}}}$$")
d(f"$$y_{{{y[1]}}}=y_{{{y[0]}}}\left(1+\\frac{{\\Delta y_{{{y[1]}}}}}{{y_{{{y[0]}}}}}\\right)$$")
d(f"$$y_{{{y[1]}}}=y_{{{y[0]}}}\left(1+\\delta^y_{{{y[1]}}}\\right)$$")
```

This, $\delta_{2020}^y$, is the **growth rate** of $y$ at year `{python} ys[1]`.

## Growth Rate

::: {.callout-note appearance="simple" icon=false}
## Growth Rate
Let $y_t$ be a variable that might take different values over time. The **growth rate** at $t$ is given by $\delta_t^y$, and takes a value such that:
$$y_t=y_{t-1}\left(1+\delta_t\right)$$

And then
$$\delta_t = \frac{y_t-y_{t-1}}{y_{t-1}}$$

<small>Note: I dropped $y$ from the notation in the formula because it is obvious that we are talking about the variable $y$.</small>

You can write the growth rate as a decimal or as a percentage. If you use decimal notation, consider at least 4 places, if you use percentage you use at least 2. Example: 0.0123 or 1.23\%.

**Interpretation**: What is the percentage change for the variable $y$ between $t-1$ and $t$.
:::


## Example

```{python}
d(f'$${v[1]}={v[0]}+({v[1]-v[0]})$$')
d(f'$${v[1]}={v[0]}\left(1+\\frac{({v[1]-v[0]})}{{{v[0]}}}\\right)$$')
d(f'$${v[1]}={v[0]}\left(1+{{{round((v[1]-v[0])/v[0], 4)}}}\\right)$$')
```

. . .

In this case $\delta_{`{python} ys[1]`}^y = `{python} round((v[1]-v[0])/v[0], 4)` = `{python} 100*round((v[1]-v[0])/v[0], 4)`\%$.

> Interpretation: Between `{python} ys[0]` and `{python} ys[1]`, the GDP for Italy *`{python} 'decreased' if v[1]-v[0]<0 else 'increased'`* `{python} abs(100*round((v[1]-v[0])/v[0], 4))`\%.

## Growth Rates

More generally $$\delta_{t+k|t}=\frac{y_{t+k}-y_t}{y_t}$$

Or $$y_{t+k}=y_t(1+\delta_{t+k|t})$$

<small>(homework: Show step by step how you go from one to the other.)</small>

> Note: In this case $\delta_{t+k|t}$ is what percentage the variable changed from $t$ to $t+k$, and $k$ is the number of periods.

## Example

We had $y_{`{python} ys[0]`}=`{python} vs[0]`$, and $y_{`{python} ys[4]`} = `{python} vs[4]`$. We will try to find $\delta_{`{python} ys[4]`|`{python} ys[0]`}^y$.

* What is the value of $k$ in this case?

. . .

  $$k=`{python} ys[4]`-`{python} ys[0]`=`{python} f'{y[4]-y[0]}'`$$

* What is the growth rate between $`{python} ys[0]`$ and $`{python} ys[4]`$ ?

. . .

$$\delta_{`{python} ys[4]`|`{python} ys[0]`}^y = \frac{`{python} vs[4]` - `{python} vs[0]`}{`{python} vs[0]`} = `{python} round((v[4]-v[0])/v[0], 4)` = `{python} 100*round((v[4]-v[0])/v[0], 4)`\%$$

> In Italy, GDP grew `{python} 100*round((v[4]-v[0])/v[0], 4)`\% between `{python} ys[0]` and `{python} ys[4]`, or GDP in Italy in `{python} ys[4]` is `{python} 100*round((v[4]-v[0])/v[0], 4)`\% larger than in `{python} ys[0]`.

## Growth Rates

::: {.callout-warning}

You should be careful with your interpretation and use of this *cumulative* growth rate, because it **does not** mean that $y$ grew $\delta_{t+k|t}^y$ **per period** between $t$ and $t+k$.

:::

. . .

\

::: {.callout-note appearance="simple" icon=false}
## Average Growth Rate
Let $y_t$ be a variable that might take different values over time. The **average growth rate** betweek $t$ and $t+k$ is given by $\overline{\delta}_{t+k|t}^y$, and takes a value such that:
$$y_{t+k}=y_t\left(1+\overline{\delta}_{t+k|t}\right)^k$$

<small>I dropped $y$ from the notation in the formula because it is obvious that we are talking about the variable $y$.</small>
:::

## Growth Rates

Let's start with $y_t$... and the traditional growth rates $\delta_t$:
$$y_{t+1} = y_t(1+\delta_t)$$
$$y_{t+2} = y_{t+1}(1+\delta_{t+1})$$
$$y_{t+3} = y_{t+1}(1+\delta_{t+2})$$

Can we write $y_{t+2}$ as a function of $y_t$?

. . .

$$y_{t+2} = y_{t+1}(1+\delta_{t+1}) = y_{t}(1+\delta_t)(1+\delta_{t+1})$$

. . . 

And $y_{t+3}$?

. . . 

$$y_{t+3} = y_{t}(1+\delta_t)(1+\delta_{t+1})(1+\delta_{t+2})$$

## Growth Rates

Generalizing

$$y_{t+k}=y_t (1+\delta_t)(1+\delta_{t+1})...(1+\delta_{t+k-1})$$

When computing the average growth rate, we are trying to find $\overline{\delta}$ such that if the growth rate was the same every period, it would have taken $y_t$ to the value of $y_{t+k}$ all the same:

$$y_{t+k}=y_t(1+\overline{\delta})(1+\overline{\delta})...(1+\overline{\delta})$$

. . . 

How many times is $(1+\overline{\delta})$ multiplied in the expression?

## Growth Rates

$$y_{t+k} = y_t \left(1+\overline{\delta}\right)^k$$

. . .

$$\frac{y_{t+k}}{y_t} = \left(1+\overline{\delta}\right)^k$$

. . .

$$\left(\frac{y_{t+k}}{y_t}\right)^{1/k} = \left(1+\overline{\delta}\right)$$

. . .

$$\left(\frac{y_{t+k}}{y_t}\right)^{1/k} - 1 = \overline{\delta}$$

$$\overline{\delta}_{t+k|t}=\left(\frac{y_{t+k}}{y_t}\right)^{1/k} - 1$$

## Example

We had $$\delta_{`{python} ys[4]`|`{python} ys[0]`}^y = \frac{`{python} vs[4]` - `{python} vs[0]`}{`{python} vs[0]`} = `{python} round((v[4]-v[0])/v[0], 4)` = `{python} 100*round((v[4]-v[0])/v[0], 4)`\%$$

But what now is the **average growth rate** between `{python} ys[0]` and `{python} ys[4]`?

. . .

Remember $k = `{python} f'{y[4]-y[0]}'`$!

$$\overline{\delta} = \left(\frac{`{python} vs[4]`}{`{python} vs[0]`}\right)^{1/`{python} f'{y[4]-y[0]}'`} - 1 \approx `{python} float(round((v[4]/v[0])**(1/(y[4]-y[0]))-1,4))`=`{python} round(100*float((v[4]/v[0])**(1/(y[4]-y[0]))-1),2)`\%$$


> Interpretation: On average, between `{python} ys[0]` and `{python} ys[4]` $y$ `{python} 'grew' if y[4]>y[0] else 'decreased'` `{python} round(100*float((v[4]/v[0])**(1/(y[4]-y[0]))-1),2)`\% every year.

## Example

Note that $$(1+`{python} round(100*float((v[4]/v[0])**(1/(y[4]-y[0]))-1),2)`\%)^`{python} f'{y[4]-y[0]}'` = (1+`{python} float(round((v[4]/v[0])**(1/(y[4]-y[0]))-1,4))`)^`{python} f'{y[4]-y[0]}'` \approx `{python} 1+round((v[4]-v[0])/v[0], 4)` \approx 1 + `{python} round(100*(v[4]-v[0])/v[0], 2)`\%$$


# Index Numbers - Introduction and Simple Index Numbers

## Motivation

```{python}
import yfinance as yf

high_price_stock = "NFLX"  
low_price_stock = "AAPL"   

# Set up date range for last 10 years
end_date = datetime.now()
start_date = end_date - timedelta(days = 10*365)

high_stock_prices = yf.download(high_price_stock, start = start_date, end = end_date)['Close']
low_stock_prices = yf.download(low_price_stock, start = start_date, end = end_date)['Close']
```

```{python}
#| echo: false

plt.figure(figsize = (12, 7))
    
# Plot both stocks on the same y-axis (same scale)
plt.plot(high_stock_prices.index, high_stock_prices.values, color = 'blue', linewidth = 3, label = f'{high_price_stock}')
plt.plot(low_stock_prices.index, low_stock_prices.values, color = 'red', linewidth = 3, label = f'{low_price_stock}')

# Add labels and formatting
plt.xlabel('Date', fontsize = 12)
plt.ylabel('Stock Price ($)', fontsize = 12)
plt.title(f'{high_price_stock} vs {low_price_stock}', fontsize = 14, pad = 20)
plt.legend(fontsize = 12)
plt.grid(True, alpha = 0.3)

plt.tight_layout()
plt.show()
```

Which stock would you have purchased in `{python} start_date.year`?

## Motivation

What's the important question here?

. . .

Which one grew more! For this, levels are not as relevant as their evolution over time.

For example, say we have prices for two stocks A and B. Say we want to hold these stocks for only one period, which one would choose to invest your hard earned :dollar:?

. . .

How many stocks will you be able to buy of each stock, if their prices are $a_t$ and $b_t$, and you have US$1000?

. . .

$n_a=\frac{1000}{a_t}$ of stock A and $n_b=\frac{1000}{b_t}$ of stock $B$. Note that $n_a$ and $n_b$ are the amount of stock you can buy of each.

## Motivation

Now is a new day :sunrise_over_mountains:! Prices are now $a_{t+1}$ and $b_{t+1}$, how much is your portfolio worth today?

. . .

1. If you bought stock A: $a_{t+1} n_a = a_{t+1}\frac{1000}{a_t}$
2. If you bought stock B: $b_{t+1} n_b = b_{t+1}\frac{1000}{b_t}$

. . .

Note that the 1000 is fixed, so it is just what we invested, it is not going to change anything in our decision on buying A vs B, what is really important is $\frac{a_{t+1}}{a_t}$ and $\frac{b_{t+1}}{b_t}$, that is the growth rate of prices for each stock, as

$$\frac{a_{t+1}}{a_t}=1+\delta_{t+1}^a \quad\text{and}\quad \frac{b_{t+1}}{b_t}=1+\delta_{t+1}^b$$

## Motivation

You did not sell and...

Now is (another) new day :sunrise_over_mountains:! Prices are now $a_{t+2}$ and $b_{t+2}$, how much is your portfolio worth today?

. . .

1. If you bought stock A: $a_{t+2} n_a = a_{t+2}\frac{1000}{a_t}$
2. If you bought stock B: $b_{t+2} n_b = b_{t+2}\frac{1000}{b_t}$

. . .

blah, blah... 

$$\frac{a_{t+2}}{a_t}=1+\delta_{t+2}^a \quad\text{and}\quad \frac{b_{t+2}}{b_t}=1+\delta_{t+2}^b$$

If we wait two days, we only care how is the price today compared to when we made the purchase. We could make instead a plot of $1+\delta_{t+k}$ to see which grew more!

## Motivation

```{python}
#| echo: false

high_p = high_stock_prices/high_stock_prices.iloc[0,0]
low_p = low_stock_prices/low_stock_prices.iloc[0,0]

plt.figure(figsize = (12, 5))
    
# Plot both stocks on the same y-axis (same scale)
plt.plot(high_p.index, high_p.values, color = 'blue', linewidth = 3, label = f'{high_price_stock}')
plt.plot(low_p.index, low_p.values, color = 'red', linewidth = 3, label = f'{low_price_stock}')

# Add labels and formatting
plt.xlabel('Date', fontsize = 12)
plt.ylabel(f'Price Evolution Compared to {start_date.day}/{start_date.month}/{start_date.year}', fontsize = 12)
plt.title(f'{high_price_stock} vs {low_price_stock}', fontsize = 14, pad = 20)
plt.legend(fontsize = 12)
plt.grid(True, alpha = 0.3)

plt.tight_layout()
plt.show()
```

Now we have a much clear picture. We can compare their evolution starting in `{python} f'{start_date.day}/{start_date.month}/{start_date.year}'`.

\

What can you read from the plot?

## Motivation

Note that for `{python} f'{start_date.day}/{start_date.month}/{start_date.year}'`, we would have, for A and B:

$$1+\frac{a_t-a_t}{a_t}=1\quad\text{and}\quad 1+\frac{b_t-b_t}{b_t}=1$$

We just built and index number!

By convention though, instead of using 1 for the reference date, we will use 100 (as in 100\%) for the reference day (we will put a name to this in a few moments).

\

When our new series was 2, we understood that $1+\delta_{t+k}=2$ or $\delta_{t+k}=1$, *i.e.* the price grew 100\%, or *doubled*! Now, with the new notation, we would have that the new series would take the value of 200, *i.e.* the price is now 200\% the value it had at our initial date.

## Index Numbers

::: {.callout-note appearance="simple" icon=false}
## Index Number
An **Index Number** is a scaled variable that takes as a reference point the value an underlying variable took at a fixed point in time. Say, for an underlying variable $x_t$ we build an index $I_t$.

$$I_t=\frac{x_t}{x_0}\times 100$$

Where $x_t$ is the value the underlying variable takes at time $t$, and $x_0$ representes the value this variable took at our reference point. This period is called **base**.

>Note: In this case we used time as the dimension for $t$ but this needs not be the case, we will see examples later.
:::

\

In our previous example, the base day would have been `{python} f'{start_date.day}/{start_date.month}/{start_date.year}'`. Note that in the base period $$I_0=\frac{x_0}{x_0}\times 100 = 100$$

## Index Numbers

Index Numbers are defined by their underlying variable. This can change over time, or it can change according to another dimension, like geography, or both! We will see examples.

Also, an Index Number can have a fixed base or a moving base.

```{mermaid}
flowchart TD
  A[Index] --> B(Underlying Variable)
  A --> C(Base)
  A --> D(Dimension)

  B --> E[Simple]
  B --> F[Composite]

  C --> G[Fixed]
  C --> H[Rolling]

  D --> I[Chronological]
  D --> J[Geographical]
  
```

* Simple and Composite are mutually exclusive
* Fixed and Moving are mutually exclusive
* Rolling always needs a chronological dimension

## Examples

| Type | Example |
|------|---------|
|Simple| Single stock price|
|Composite| SP500 (market index), CPI|
|Fixed Base| GDP, CPI, market index|
|Rolling Base| Some measures of GDP, Commodities Futures|
|Chronological | Stock price over time, CPI, GDP|
|Geographical | BigMac Index |

## Index Numbers

Importantly, an index number is *no bueno* to reflect the level of a variable, but its evolution or relative value against a base.

## Rolling Base

::: {.callout-note appearance="simple" icon=false}
## Chain or Link Index
A **Chain or Link Index Number** is an index number that updates its base in every period.

$$I_t = \frac{x_t}{x_{t-1}}\times 100$$

> Interpretation: It tells you how much the variable increased compared to the **previous** period.
:::

## Index Numbers

Index numbers allow us to easily compute the growth rate between any two periods, just like we would do with the underlying variable:

1. Simple Index Number

. . .

$$1+\delta_{t+k,t}=\frac{x_{t+k}}{x_t}=\frac{x_{t+k}}{x_t}=\frac{\frac{x_{t+k}}{x_0}}{\frac{x_t}{x_0}}=\frac{I_{t+k}}{I_t}$$

2. Chain Index Number

. . .

<small>
$$1+\delta_{t+k,t}=\frac{x_{t+k}}{x_t}=\frac{x_{t+k}}{x_{t+k-1}}\frac{x_{t+k-1}}{x_{t}}=\frac{x_{t+k}}{x_{t+k-1}}\frac{x_{t+k-1}}{x_{t+k-2}}\frac{x_{t+k-2}}{x_{t}}=\frac{x_{t+k}}{x_{t+k-1}}\frac{x_{t+k-1}}{x_{t+k-2}}...\frac{x_{t+1}}{x_{t}}$$
$$1+\delta_{t+k,t}=I_{t+k}\times I_{t+k-1}\times ... \times I_{t+2} \times I_{t+1}$$
</small>

## Index Numbers


::: {.callout-warning}
## Do not use 100 index when multiplying chain or link indices, use the decimal notation.

Note that if the underlying variable does not change at all, you should expect the same value, $x_t=x_{t+1}=x_{t+2}$

In this case $I_{t+1}=\frac{x_{t+1}}{x_t}=1$ and $I_{t+2}=\frac{x_{t+2}}{x_{t+1}}=1$, and therefore $$1+\delta_{t+2,t}=1\times 1= 1$$
This is the correct way to do it :white_check_mark:.

But if instead you used the 100 to multiply: $$1+\delta_{t+2,t}=100\times 100= 10000$$ and we get that $x$ grew 100 times! (:x: because we know that $x_t=x_{t+1}=x_{t+2}$)

:::

## Index Numbers

We can always transform a chain index number into a fixed base index number.

1. Chose a reference, for example for period 3.
2. Remember: what you want to achieve: $\forall t, I'_t=\frac{x_t}{x_3}$
3. Remember: that we have $I_t=\frac{x_t}{x_{t-1}}$
4. Use what we did just before:
$$ I_t' = I_t I_{t-1} ...I_{4} = \frac{x_t}{x_{t-1}}\frac{x_{t-1}}{x_{t-2}}...\frac{x_4}{x_3}=\frac{x_t}{x_3}=I'_t$$

## Example

Suppose we want to conver this Chain Index into Fix Base index, with the base year in `{python} datetime.now().year-5`. This will be our 100.
<small>

| | `{python} datetime.now().year-5` | `{python} datetime.now().year-4` | `{python} datetime.now().year-3` | `{python} datetime.now().year-2` | `{python} datetime.now().year-1` | `{python} datetime.now().year` |
| ---            | :---: | :---:                         | :---:                         | :---:                        | :---:                         | :---:                         |
| Price          | 30    | 34                            | 37                            | 35                           | 36                            | 39                            |
|                | -     | $\frac{34}{30} 100$           | $\frac{37}{34} 100$           | $\frac{35}{37} 100$          | $\frac{36}{35} 100$           | $\frac{39}{36} 100$           |
| $I_{chain}$    | -     | `{python} round(34/30*100,1)` | `{python} round(37/34*100,1)` |`{python} round(35/37*100,1)` | `{python} round(34/35*100,1)` | `{python} round(39/36*100,1)` |
|                | -     | $100\frac{113.3}{100}$        | $113.3\frac{108.8}{100}$      | $123.3\frac{94.6}{100}$      |$116.7 \frac{97.1}{100}$       | $120\frac{108.3}{100}$        |
| $I_{t|{python} datetime.now().year-5}$| 100   | `{python} round(34/30*100,1)` | `{python} round(37/30*100,1)` | `{python} round(35/30*100,1)`|`{python} round(36/30*100,1)`  | `{python} round(39/30*100,1)` |

: Stock prices

\

Note that, for example in `{python} datetime.now().year-1`, we have $I_{`{python} datetime.now().year-1`|{python} datetime.now().year-5}=116.7$, which was computed as $123.3\times\frac{94.6}{100}$. But $123.3$ was the base `{python} datetime.now().year-5` index of the previous period, which in turn was computed as $113.3\frac{108.8}{100}$, so in reality:

$$116.7=123.3\frac{94.6}{100}=113.3\frac{108.8}{100}\frac{94.6}{100}=100\frac{113.3}{100}\frac{108.8}{100}\frac{94.6}{100}$$

If you pay attention, wou will see that we have there the product of the *chain Index* in  `{python} datetime.now().year-4`,  `{python} datetime.now().year-3`, and  `{python} datetime.now().year-2`. We divided by 100 because, to multiply, we need to divide by 100 before.

</small>

## Base Change

In case we have the data, we just need to compute the Index with the base  that we want, however, if we do not have the data, and we just have a Fix Base index, we can do it all the same!

Say we have an index with base 0. Maybe we want to change it to base 2.


## Base Change

::: {#tbl-panel layout-ncol=2}
| period | Index          | Formula              |
| ---    | ---            | ---                  |
| 0      | $I_{0|0}$      | $\frac{x_0}{x_0}$    |
| 1      | $I_{1|0}$      | $\frac{x_1}{x_0}$    |
| 2      | $I_{2|0}$      | $\frac{x_2}{x_0}$    |
| 3      | $I_{3|0}$      | $\frac{x_3}{x_0}$    |
| ...    | ...            | ...                  |
| t      | $I_{t|0}$      | $\frac{x_t}{x_0}$    |

: Base 0

| period | Index          | Formula              |
| ---    | ---            | ---                  |
| 0      | $I_{0|2}$      | $\frac{x_0}{x_2}$    |
| 1      | $I_{1|2}$      | $\frac{x_1}{x_2}$    |
| 2      | $I_{2|2}$      | $\frac{x_2}{x_2}$    |
| 3      | $I_{3|2}$      | $\frac{x_3}{x_2}$    |
| ...    | ...            | ...                  |
| t      | $I_{t|2}$      | $\frac{x_t}{x_2}$    |

: Base 2

Changing Base
:::

## Base Change

But how can we transform them, if we do not know $x_i$ $\forall i$?

. . . 

$$I_{t|2}=\frac{x_t}{x_2}=1\frac{x_t}{x_2}=\frac{1/x_0}{1/x_0}\frac{x_t}{x_2}=\frac{\frac{x_t}{x_0}}{\frac{x_2}{x_0}}=\frac{I_{t|0}}{I_{2|0}}$$

And that is how we can re-base an index without knowing the value for the underlying variable ($x_t$)!


::: {.callout-tip}
## Mixing up stuff

Previously we covered how to go from a chain index to a fix base one. Now we saw how to change the base of a fix base index. With both things together you can turn a chain index into fix base one, with base you want!
:::

## Example

| | `{python} datetime.now().year-5` | `{python} datetime.now().year-4` | `{python} datetime.now().year-3` | `{python} datetime.now().year-2` | `{python} datetime.now().year-1` | `{python} datetime.now().year` |
| ---            | :---: | :---:                         | :---:                         | :---:                        | :---:                         | :---:                         |
| Price          | 30    | 34                            | 37                            | 35                           | 36                            | 39                            |
| $I_{t|`{python} datetime.now().year-5`}$   | 100   | `{python} round(34/30*100,1)` | `{python} round(37/30*100,1)` | `{python} round(35/30*100,1)`|`{python} round(36/30*100,1)`  | `{python} round(39/30*100,1)` |
|                | $\frac{100}{123.3}$ | $\frac{113.3}{123.3}$ | $\frac{123.3}{123.3}$| $\frac{116.7}{123.3}$ | $\frac{120.0}{123.3}$ | $\frac{130.0}{123.3}$|
| $I_{t|2022}$   | `{python} round(30/37*100,1)` |`{python} round(34/37*100,1)` | `{python} round(37/37*100,1)` | `{python} round(35/37*100,1)` | `{python} round(36/37*100,1)` |`{python} round(39/37*100,1)` |

: Stock prices

> New information? Yes! For example, without any computation we know that the price in `{python} datetime.now().year` was 30\% larger than in `{python} datetime.now().year-5`, and 5.4\% larger than in `{python} datetime.now().year-3`

# Index Numbers: Composite Index Numbers

## Example: Inflation

There is one index number that, along with a few others, captures large amounts of attention from the general public attention, because it reflects a phenomenon that heavily influences policy and individual decisions, **Inflation**. The index to which we refer is the CPI (Consumer Price Index). This is a single index among a broader family of price index numbers, very relevant to gauge the inflation in an economy (PPI - Producer Price Index).

\

This is a great opportunity to introduce another classification for our index numbers:

```{mermaid}
flowchart LR
  A[Index Number] --> B[Prices $P$]
  A --> C[Quantities $Q$]
  A --> D[Value $P\times Q$]
```